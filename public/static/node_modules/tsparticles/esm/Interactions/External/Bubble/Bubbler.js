import _createForOfIteratorHelper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createForOfIteratorHelper";
import _asyncToGenerator from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _inherits from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _createSuper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createSuper";

function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    };
    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function(innerFn, self, context) {
            var state = "suspendedStart";
            return function(method, arg) {
                if ("executing" === state) throw new Error("Generator is already running");
                if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                }
                for (context.method = method, context.arg = arg;;) {
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }
                    if ("next" === context.method) context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                        if ("suspendedStart" === state) throw state = "completed", context.arg;
                        context.dispatchException(context.arg);
                    } else "return" === context.method && context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);
                    if ("normal" === record.type) {
                        if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    }
                    "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                }
            };
        }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }

    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg,
                    value = result.value;
                return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
    }

    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
        this.tryEntries = [{
            tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                        for (; ++i < iterable.length;) {
                            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                        }
                        return next.value = undefined, next.done = !0, next;
                    };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }

    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(object) {
        var keys = [];
        for (var key in object) {
            keys.push(key);
        }
        return keys.reverse(),
            function next() {
                for (; keys.length;) {
                    var key = keys.pop();
                    if (key in object) return next.value = key, next.done = !1, next;
                }
                return next.done = !0, next;
            };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                for (var name in this) {
                    "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
                }
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;

            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i],
                    record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                        hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        catch: function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}

import {
    clamp,
    getDistance,
    getRangeMax
} from "../../../Utils/NumberUtils";
import {
    colorMix,
    colorToHsl,
    rgbToHsl
} from "../../../Utils/ColorUtils";
import {
    divMode,
    divModeExecute,
    isDivModeEnabled,
    isInArray,
    itemFromArray
} from "../../../Utils/Utils";
import {
    Circle
} from "../../../Core/Utils/Circle";
import {
    Constants
} from "../../../Core/Utils/Constants";
import {
    ExternalInteractorBase
} from "../../../Core/Utils/ExternalInteractorBase";
import {
    Rectangle
} from "../../../Core/Utils/Rectangle";

function calculateBubbleValue(particleValue, modeValue, optionsValue, ratio) {
    if (modeValue >= optionsValue) {
        var value = particleValue + (modeValue - optionsValue) * ratio;
        return clamp(value, particleValue, modeValue);
    } else if (modeValue < optionsValue) {
        var _value = particleValue - (optionsValue - modeValue) * ratio;

        return clamp(_value, modeValue, particleValue);
    }
}

export var Bubbler = /*#__PURE__*/ function(_ExternalInteractorBa) {
    _inherits(Bubbler, _ExternalInteractorBa);

    var _super = _createSuper(Bubbler);

    function Bubbler(container) {
        var _this;

        _classCallCheck(this, Bubbler);

        _this = _super.call(this, container);

        if (!container.bubble) {
            container.bubble = {};
        }

        _this.handleClickMode = function(mode) {
            if (mode !== "bubble") {
                return;
            }

            if (!container.bubble) {
                container.bubble = {};
            }

            container.bubble.clicking = true;
        };

        return _this;
    }

    _createClass(Bubbler, [{
        key: "isEnabled",
        value: function isEnabled() {
            var container = this.container,
                options = container.actualOptions,
                mouse = container.interactivity.mouse,
                events = options.interactivity.events,
                divs = events.onDiv,
                divBubble = isDivModeEnabled("bubble", divs);

            if (!(divBubble || events.onHover.enable && mouse.position || events.onClick.enable && mouse.clickPosition)) {
                return false;
            }

            var hoverMode = events.onHover.mode;
            var clickMode = events.onClick.mode;
            return isInArray("bubble", hoverMode) || isInArray("bubble", clickMode) || divBubble;
        }
    }, {
        key: "reset",
        value: function reset(particle, force) {
            if (!(!particle.bubble.inRange || force)) {
                return;
            }

            delete particle.bubble.div;
            delete particle.bubble.opacity;
            delete particle.bubble.radius;
            delete particle.bubble.color;
        }
    }, {
        key: "interact",
        value: function() {
            var _interact = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {
                var _this2 = this;

                var options, events, onHover, onClick, hoverEnabled, hoverMode, clickEnabled, clickMode, divs;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                options = this.container.actualOptions, events = options.interactivity.events, onHover = events.onHover, onClick = events.onClick, hoverEnabled = onHover.enable, hoverMode = onHover.mode, clickEnabled = onClick.enable, clickMode = onClick.mode, divs = events.onDiv;

                                if (hoverEnabled && isInArray("bubble", hoverMode)) {
                                    this.hoverBubble();
                                } else if (clickEnabled && isInArray("bubble", clickMode)) {
                                    this.clickBubble();
                                } else {
                                    divModeExecute("bubble", divs, function(selector, div) {
                                        return _this2.singleSelectorHover(selector, div);
                                    });
                                }

                            case 2:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function interact() {
                return _interact.apply(this, arguments);
            }

            return interact;
        }()
    }, {
        key: "singleSelectorHover",
        value: function singleSelectorHover(selector, div) {
            var _this3 = this;

            var container = this.container,
                selectors = document.querySelectorAll(selector);

            if (!selectors.length) {
                return;
            }

            selectors.forEach(function(item) {
                var elem = item,
                    pxRatio = container.retina.pixelRatio,
                    pos = {
                        x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                        y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio
                    },
                    repulseRadius = elem.offsetWidth / 2 * pxRatio,
                    area = div.type === "circle" ? new Circle(pos.x, pos.y, repulseRadius) : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio),
                    query = container.particles.quadTree.query(area);

                var _iterator = _createForOfIteratorHelper(query),
                    _step;

                try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var particle = _step.value;

                        if (!area.contains(particle.getPosition())) {
                            continue;
                        }

                        particle.bubble.inRange = true;
                        var divs = container.actualOptions.interactivity.modes.bubble.divs;
                        var divBubble = divMode(divs, elem);

                        if (!particle.bubble.div || particle.bubble.div !== elem) {
                            _this3.reset(particle, true);

                            particle.bubble.div = elem;
                        }

                        _this3.hoverBubbleSize(particle, 1, divBubble);

                        _this3.hoverBubbleOpacity(particle, 1, divBubble);

                        _this3.hoverBubbleColor(particle, 1, divBubble);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally {
                    _iterator.f();
                }
            });
        }
    }, {
        key: "process",
        value: function process(particle, distMouse, timeSpent, data) {
            var container = this.container,
                bubbleParam = data.bubbleObj.optValue;

            if (bubbleParam === undefined) {
                return;
            }

            var options = container.actualOptions,
                bubbleDuration = options.interactivity.modes.bubble.duration,
                bubbleDistance = container.retina.bubbleModeDistance,
                particlesParam = data.particlesObj.optValue,
                pObjBubble = data.bubbleObj.value,
                pObj = data.particlesObj.value || 0,
                type = data.type;

            if (bubbleParam === particlesParam) {
                return;
            }

            if (!container.bubble) {
                container.bubble = {};
            }

            if (!container.bubble.durationEnd) {
                if (distMouse <= bubbleDistance) {
                    var obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;

                    if (obj !== bubbleParam) {
                        var value = pObj - timeSpent * (pObj - bubbleParam) / bubbleDuration;

                        if (type === "size") {
                            particle.bubble.radius = value;
                        }

                        if (type === "opacity") {
                            particle.bubble.opacity = value;
                        }
                    }
                } else {
                    if (type === "size") {
                        delete particle.bubble.radius;
                    }

                    if (type === "opacity") {
                        delete particle.bubble.opacity;
                    }
                }
            } else if (pObjBubble) {
                if (type === "size") {
                    delete particle.bubble.radius;
                }

                if (type === "opacity") {
                    delete particle.bubble.opacity;
                }
            }
        }
    }, {
        key: "clickBubble",
        value: function clickBubble() {
            var _a, _b;

            var container = this.container,
                options = container.actualOptions,
                mouseClickPos = container.interactivity.mouse.clickPosition;

            if (!mouseClickPos) {
                return;
            }

            if (!container.bubble) {
                container.bubble = {};
            }

            var distance = container.retina.bubbleModeDistance,
                query = container.particles.quadTree.queryCircle(mouseClickPos, distance);

            var _iterator2 = _createForOfIteratorHelper(query),
                _step2;

            try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var particle = _step2.value;

                    if (!container.bubble.clicking) {
                        continue;
                    }

                    particle.bubble.inRange = !container.bubble.durationEnd;
                    var pos = particle.getPosition(),
                        distMouse = getDistance(pos, mouseClickPos),
                        timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;

                    if (timeSpent > options.interactivity.modes.bubble.duration) {
                        container.bubble.durationEnd = true;
                    }

                    if (timeSpent > options.interactivity.modes.bubble.duration * 2) {
                        container.bubble.clicking = false;
                        container.bubble.durationEnd = false;
                    }

                    var sizeData = {
                        bubbleObj: {
                            optValue: container.retina.bubbleModeSize,
                            value: particle.bubble.radius
                        },
                        particlesObj: {
                            optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,
                            value: particle.size.value
                        },
                        type: "size"
                    };
                    this.process(particle, distMouse, timeSpent, sizeData);
                    var opacityData = {
                        bubbleObj: {
                            optValue: options.interactivity.modes.bubble.opacity,
                            value: particle.bubble.opacity
                        },
                        particlesObj: {
                            optValue: getRangeMax(particle.options.opacity.value),
                            value: (_b = (_a = particle.opacity) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1
                        },
                        type: "opacity"
                    };
                    this.process(particle, distMouse, timeSpent, opacityData);

                    if (!container.bubble.durationEnd) {
                        if (distMouse <= container.retina.bubbleModeDistance) {
                            this.hoverBubbleColor(particle, distMouse);
                        } else {
                            delete particle.bubble.color;
                        }
                    } else {
                        delete particle.bubble.color;
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally {
                _iterator2.f();
            }
        }
    }, {
        key: "hoverBubble",
        value: function hoverBubble() {
            var container = this.container,
                mousePos = container.interactivity.mouse.position;

            if (mousePos === undefined) {
                return;
            }

            var distance = container.retina.bubbleModeDistance,
                query = container.particles.quadTree.queryCircle(mousePos, distance);

            var _iterator3 = _createForOfIteratorHelper(query),
                _step3;

            try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var particle = _step3.value;
                    particle.bubble.inRange = true;
                    var pos = particle.getPosition(),
                        pointDistance = getDistance(pos, mousePos),
                        ratio = 1 - pointDistance / distance;

                    if (pointDistance <= distance) {
                        if (ratio >= 0 && container.interactivity.status === Constants.mouseMoveEvent) {
                            this.hoverBubbleSize(particle, ratio);
                            this.hoverBubbleOpacity(particle, ratio);
                            this.hoverBubbleColor(particle, ratio);
                        }
                    } else {
                        this.reset(particle);
                    }

                    if (container.interactivity.status === Constants.mouseLeaveEvent) {
                        this.reset(particle);
                    }
                }
            } catch (err) {
                _iterator3.e(err);
            } finally {
                _iterator3.f();
            }
        }
    }, {
        key: "hoverBubbleSize",
        value: function hoverBubbleSize(particle, ratio, divBubble) {
            var container = this.container,
                modeSize = (divBubble === null || divBubble === void 0 ? void 0 : divBubble.size) ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;

            if (modeSize === undefined) {
                return;
            }

            var optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio;
            var pSize = particle.size.value;
            var size = calculateBubbleValue(pSize, modeSize, optSize, ratio);

            if (size !== undefined) {
                particle.bubble.radius = size;
            }
        }
    }, {
        key: "hoverBubbleOpacity",
        value: function hoverBubbleOpacity(particle, ratio, divBubble) {
            var _a, _b, _c;

            var container = this.container,
                options = container.actualOptions,
                modeOpacity = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.opacity;

            if (!modeOpacity) {
                return;
            }

            var optOpacity = particle.options.opacity.value;
            var pOpacity = (_c = (_b = particle.opacity) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : 1;
            var opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);

            if (opacity !== undefined) {
                particle.bubble.opacity = opacity;
            }
        }
    }, {
        key: "hoverBubbleColor",
        value: function hoverBubbleColor(particle, ratio, divBubble) {
            var options = this.container.actualOptions;
            var bubbleOptions = divBubble !== null && divBubble !== void 0 ? divBubble : options.interactivity.modes.bubble;

            if (!particle.bubble.finalColor) {
                var modeColor = bubbleOptions.color;

                if (!modeColor) {
                    return;
                }

                var bubbleColor = modeColor instanceof Array ? itemFromArray(modeColor) : modeColor;
                particle.bubble.finalColor = colorToHsl(bubbleColor);
            }

            if (!particle.bubble.finalColor) {
                return;
            }

            if (bubbleOptions.mix) {
                particle.bubble.color = undefined;
                var pColor = particle.getFillColor();
                particle.bubble.color = pColor ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, 1 - ratio, ratio)) : particle.bubble.finalColor;
            } else {
                particle.bubble.color = particle.bubble.finalColor;
            }
        }
    }]);

    return Bubbler;
}(ExternalInteractorBase);