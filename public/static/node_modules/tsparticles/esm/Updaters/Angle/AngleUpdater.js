import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import {
    getRangeValue
} from "../../Utils/NumberUtils";

function updateAngle(particle, delta) {
    var _a;

    var rotate = particle.rotate;

    if (!rotate) {
        return;
    }

    var rotateOptions = particle.options.rotate;
    var rotateAnimation = rotateOptions.animation;
    var speed = ((_a = rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
    var max = 2 * Math.PI;

    if (!rotateAnimation.enable) {
        return;
    }

    switch (rotate.status) {
        case 0:
            rotate.value += speed;

            if (rotate.value > max) {
                rotate.value -= max;
            }

            break;

        case 1:
        default:
            rotate.value -= speed;

            if (rotate.value < 0) {
                rotate.value += max;
            }

            break;
    }
}

export var AngleUpdater = /*#__PURE__*/ function() {
    function AngleUpdater(container) {
        _classCallCheck(this, AngleUpdater);

        this.container = container;
    }

    _createClass(AngleUpdater, [{
        key: "init",
        value: function init(particle) {
            var rotateOptions = particle.options.rotate;
            particle.rotate = {
                enable: rotateOptions.animation.enable,
                value: getRangeValue(rotateOptions.value) * Math.PI / 180
            };
            var rotateDirection = rotateOptions.direction;

            if (rotateDirection === "random") {
                var index = Math.floor(Math.random() * 2);
                rotateDirection = index > 0 ? "counter-clockwise" : "clockwise";
            }

            switch (rotateDirection) {
                case "counter-clockwise":
                case "counterClockwise":
                    particle.rotate.status = 1;
                    break;

                case "clockwise":
                    particle.rotate.status = 0;
                    break;
            }

            var rotateAnimation = particle.options.rotate.animation;

            if (rotateAnimation.enable) {
                particle.rotate.velocity = getRangeValue(rotateAnimation.speed) / 360 * this.container.retina.reduceFactor;

                if (!rotateAnimation.sync) {
                    particle.rotate.velocity *= Math.random();
                }
            }
        }
    }, {
        key: "isEnabled",
        value: function isEnabled(particle) {
            var rotate = particle.options.rotate;
            var rotateAnimation = rotate.animation;
            return !particle.destroyed && !particle.spawning && !rotate.path && rotateAnimation.enable;
        }
    }, {
        key: "update",
        value: function update(particle, delta) {
            if (!this.isEnabled(particle)) {
                return;
            }

            updateAngle(particle, delta);
        }
    }]);

    return AngleUpdater;
}();