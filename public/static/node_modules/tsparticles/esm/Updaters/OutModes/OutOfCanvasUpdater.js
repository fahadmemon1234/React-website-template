import _slicedToArray from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/slicedToArray";
import _createForOfIteratorHelper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createForOfIteratorHelper";
import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import {
    bounceHorizontal,
    bounceVertical
} from "./Utils";
import {
    calculateBounds,
    isPointInside
} from "../../Utils/Utils";
export var OutOfCanvasUpdater = /*#__PURE__*/ function() {
    function OutOfCanvasUpdater(container) {
        _classCallCheck(this, OutOfCanvasUpdater);

        this.container = container;
    }

    _createClass(OutOfCanvasUpdater, [{
        key: "init",
        value: function init() {}
    }, {
        key: "isEnabled",
        value: function isEnabled(particle) {
            return !particle.destroyed && !particle.spawning;
        }
    }, {
        key: "update",
        value: function update(particle, delta) {
            var _a, _b, _c, _d;

            var outModes = particle.options.move.outModes;
            this.updateOutMode(particle, delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, "bottom");
            this.updateOutMode(particle, delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, "left");
            this.updateOutMode(particle, delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, "right");
            this.updateOutMode(particle, delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, "top");
        }
    }, {
        key: "updateOutMode",
        value: function updateOutMode(particle, delta, outMode, direction) {
            switch (outMode) {
                case "bounce":
                case "bounce-vertical":
                case "bounce-horizontal":
                case "bounceVertical":
                case "bounceHorizontal":
                case "split":
                    this.bounce(particle, delta, direction, outMode);
                    break;

                case "destroy":
                    this.destroy(particle, direction);
                    break;

                case "out":
                    this.out(particle, direction);
                    break;

                case "none":
                default:
                    this.none(particle, direction);
                    break;
            }
        }
    }, {
        key: "destroy",
        value: function destroy(particle, direction) {
            var container = this.container;

            if (isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                return;
            }

            container.particles.remove(particle, undefined, true);
        }
    }, {
        key: "out",
        value: function out(particle, direction) {
            var container = this.container;

            if (isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                return;
            }

            var wrap = particle.options.move.warp,
                canvasSize = container.canvas.size,
                newPos = {
                    bottom: canvasSize.height + particle.getRadius() + particle.offset.y,
                    left: -particle.getRadius() - particle.offset.x,
                    right: canvasSize.width + particle.getRadius() + particle.offset.x,
                    top: -particle.getRadius() - particle.offset.y
                },
                sizeValue = particle.getRadius(),
                nextBounds = calculateBounds(particle.position, sizeValue);

            if (direction === "right" && nextBounds.left > canvasSize.width + particle.offset.x) {
                particle.position.x = newPos.left;
                particle.initialPosition.x = particle.position.x;

                if (!wrap) {
                    particle.position.y = Math.random() * canvasSize.height;
                    particle.initialPosition.y = particle.position.y;
                }
            } else if (direction === "left" && nextBounds.right < -particle.offset.x) {
                particle.position.x = newPos.right;
                particle.initialPosition.x = particle.position.x;

                if (!wrap) {
                    particle.position.y = Math.random() * canvasSize.height;
                    particle.initialPosition.y = particle.position.y;
                }
            }

            if (direction === "bottom" && nextBounds.top > canvasSize.height + particle.offset.y) {
                if (!wrap) {
                    particle.position.x = Math.random() * canvasSize.width;
                    particle.initialPosition.x = particle.position.x;
                }

                particle.position.y = newPos.top;
                particle.initialPosition.y = particle.position.y;
            } else if (direction === "top" && nextBounds.bottom < -particle.offset.y) {
                if (!wrap) {
                    particle.position.x = Math.random() * canvasSize.width;
                    particle.initialPosition.x = particle.position.x;
                }

                particle.position.y = newPos.bottom;
                particle.initialPosition.y = particle.position.y;
            }
        }
    }, {
        key: "bounce",
        value: function bounce(particle, delta, direction, outMode) {
            var container = this.container;
            var handled = false;

            var _iterator = _createForOfIteratorHelper(container.plugins),
                _step;

            try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var _step$value = _slicedToArray(_step.value, 2),
                        plugin = _step$value[1];

                    if (plugin.particleBounce !== undefined) {
                        handled = plugin.particleBounce(particle, delta, direction);
                    }

                    if (handled) {
                        break;
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }

            if (handled) {
                return;
            }

            var pos = particle.getPosition(),
                offset = particle.offset,
                size = particle.getRadius(),
                bounds = calculateBounds(pos, size),
                canvasSize = container.canvas.size;
            bounceHorizontal({
                particle: particle,
                outMode: outMode,
                direction: direction,
                bounds: bounds,
                canvasSize: canvasSize,
                offset: offset,
                size: size
            });
            bounceVertical({
                particle: particle,
                outMode: outMode,
                direction: direction,
                bounds: bounds,
                canvasSize: canvasSize,
                offset: offset,
                size: size
            });
        }
    }, {
        key: "none",
        value: function none(particle, direction) {
            if (particle.options.move.distance.horizontal && (direction === "left" || direction === "right") || particle.options.move.distance.vertical && (direction === "top" || direction === "bottom")) {
                return;
            }

            var gravityOptions = particle.options.move.gravity,
                container = this.container;
            var canvasSize = container.canvas.size;
            var pRadius = particle.getRadius();

            if (!gravityOptions.enable) {
                if (particle.velocity.y > 0 && particle.position.y <= canvasSize.height + pRadius || particle.velocity.y < 0 && particle.position.y >= -pRadius || particle.velocity.x > 0 && particle.position.x <= canvasSize.width + pRadius || particle.velocity.x < 0 && particle.position.x >= -pRadius) {
                    return;
                }

                if (!isPointInside(particle.position, container.canvas.size, pRadius, direction)) {
                    container.particles.remove(particle);
                }
            } else {
                var position = particle.position;

                if (!gravityOptions.inverse && position.y > canvasSize.height + pRadius && direction === "bottom" || gravityOptions.inverse && position.y < -pRadius && direction === "top") {
                    container.particles.remove(particle);
                }
            }
        }
    }]);

    return OutOfCanvasUpdater;
}();