import _createForOfIteratorHelper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createForOfIteratorHelper";
import _asyncToGenerator from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";

function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    };
    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function(innerFn, self, context) {
            var state = "suspendedStart";
            return function(method, arg) {
                if ("executing" === state) throw new Error("Generator is already running");
                if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                }
                for (context.method = method, context.arg = arg;;) {
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }
                    if ("next" === context.method) context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                        if ("suspendedStart" === state) throw state = "completed", context.arg;
                        context.dispatchException(context.arg);
                    } else "return" === context.method && context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);
                    if ("normal" === record.type) {
                        if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    }
                    "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                }
            };
        }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }

    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg,
                    value = result.value;
                return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
    }

    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
        this.tryEntries = [{
            tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                        for (; ++i < iterable.length;) {
                            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                        }
                        return next.value = undefined, next.done = !0, next;
                    };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }

    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(object) {
        var keys = [];
        for (var key in object) {
            keys.push(key);
        }
        return keys.reverse(),
            function next() {
                for (; keys.length;) {
                    var key = keys.pop();
                    if (key in object) return next.value = key, next.done = !1, next;
                }
                return next.done = !0, next;
            };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                for (var name in this) {
                    "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
                }
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;

            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i],
                    record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                        hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        catch: function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}

import {
    calcClosestPtOnSegment,
    drawPolygonMask,
    drawPolygonMaskPath,
    parsePaths,
    segmentBounce
} from "./Utils";
import {
    deepExtend,
    itemFromArray
} from "../../Utils/Utils";
import {
    getDistance,
    getDistances
} from "../../Utils/NumberUtils";
import {
    Constants
} from "../../Core/Utils/Constants";
import {
    PolygonMask
} from "./Options/Classes/PolygonMask";
export var PolygonMaskInstance = /*#__PURE__*/ function() {
    function PolygonMaskInstance(container) {
        _classCallCheck(this, PolygonMaskInstance);

        this.container = container;
        this.dimension = {
            height: 0,
            width: 0
        };
        this.path2DSupported = !!window.Path2D;
        this.options = new PolygonMask();
        this.polygonMaskMoveRadius = this.options.move.radius * container.retina.pixelRatio;
    }

    _createClass(PolygonMaskInstance, [{
        key: "initAsync",
        value: function() {
            var _initAsync = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee(options) {
                var polygonMaskOptions;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                this.options.load(options === null || options === void 0 ? void 0 : options.polygon);
                                polygonMaskOptions = this.options;
                                this.polygonMaskMoveRadius = polygonMaskOptions.move.radius * this.container.retina.pixelRatio;

                                if (!polygonMaskOptions.enable) {
                                    _context.next = 6;
                                    break;
                                }

                                _context.next = 6;
                                return this.initRawData();

                            case 6:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function initAsync(_x) {
                return _initAsync.apply(this, arguments);
            }

            return initAsync;
        }()
    }, {
        key: "resize",
        value: function resize() {
            var _this = this;

            var container = this.container,
                options = this.options;

            if (!(options.enable && options.type !== "none")) {
                return;
            }

            if (this.redrawTimeout) {
                clearTimeout(this.redrawTimeout);
            }

            this.redrawTimeout = window.setTimeout( /*#__PURE__*/ _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee2() {
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return _this.initRawData(true);

                            case 2:
                                _context2.next = 4;
                                return container.particles.redraw();

                            case 4:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2);
            })), 250);
        }
    }, {
        key: "stop",
        value: function stop() {
            delete this.raw;
            delete this.paths;
        }
    }, {
        key: "particlesInitialization",
        value: function particlesInitialization() {
            var options = this.options;

            if (options.enable && options.type === "inline" && (options.inline.arrangement === "one-per-point" || options.inline.arrangement === "per-point")) {
                this.drawPoints();
                return true;
            }

            return false;
        }
    }, {
        key: "particlePosition",
        value: function particlePosition(position) {
            var _a, _b;

            var options = this.options;

            if (!(options.enable && ((_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0)) {
                return;
            }

            return deepExtend({}, position ? position : this.randomPoint());
        }
    }, {
        key: "particleBounce",
        value: function particleBounce(particle, delta, direction) {
            return this.polygonBounce(particle, delta, direction);
        }
    }, {
        key: "clickPositionValid",
        value: function clickPositionValid(position) {
            var options = this.options;
            return options.enable && options.type !== "none" && options.type !== "inline" && this.checkInsidePolygon(position);
        }
    }, {
        key: "draw",
        value: function draw(context) {
            var _a;

            if (!((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
                return;
            }

            var options = this.options,
                polygonDraw = options.draw;

            if (!options.enable || !polygonDraw.enable) {
                return;
            }

            var rawData = this.raw;

            var _iterator = _createForOfIteratorHelper(this.paths),
                _step;

            try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var path = _step.value;
                    var path2d = path.path2d,
                        path2dSupported = this.path2DSupported;

                    if (!context) {
                        continue;
                    }

                    if (path2dSupported && path2d && this.offset) {
                        drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);
                    } else if (rawData) {
                        drawPolygonMask(context, rawData, polygonDraw.stroke);
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }
        }
    }, {
        key: "polygonBounce",
        value: function polygonBounce(particle, _delta, direction) {
            var options = this.options;

            if (!this.raw || !options.enable || direction !== "top") {
                return false;
            }

            if (options.type === "inside" || options.type === "outside") {
                var closest, dx, dy;
                var pos = particle.getPosition(),
                    radius = particle.getRadius();

                for (var i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {
                    var pi = this.raw[i],
                        pj = this.raw[j];
                    closest = calcClosestPtOnSegment(pi, pj, pos);
                    var dist = getDistances(pos, closest);
                    var _ref2 = [dist.dx, dist.dy];
                    dx = _ref2[0];
                    dy = _ref2[1];

                    if (dist.distance < radius) {
                        segmentBounce(pi, pj, particle.velocity);
                        return true;
                    }
                }

                if (closest && dx !== undefined && dy !== undefined && !this.checkInsidePolygon(pos)) {
                    var factor = {
                        x: 1,
                        y: 1
                    };

                    if (particle.position.x >= closest.x) {
                        factor.x = -1;
                    }

                    if (particle.position.y >= closest.y) {
                        factor.y = -1;
                    }

                    particle.position.x = closest.x + radius * 2 * factor.x;
                    particle.position.y = closest.y + radius * 2 * factor.y;
                    particle.velocity.mult(-1);
                    return true;
                }
            } else if (options.type === "inline" && particle.initialPosition) {
                var _dist = getDistance(particle.initialPosition, particle.getPosition());

                if (_dist > this.polygonMaskMoveRadius) {
                    particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;
                    particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;
                    return true;
                }
            }

            return false;
        }
    }, {
        key: "checkInsidePolygon",
        value: function checkInsidePolygon(position) {
            var _a, _b;

            var container = this.container,
                options = this.options;

            if (!options.enable || options.type === "none" || options.type === "inline") {
                return true;
            }

            if (!this.raw) {
                throw new Error(Constants.noPolygonFound);
            }

            var canvasSize = container.canvas.size,
                x = (_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * canvasSize.width,
                y = (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * canvasSize.height;
            var inside = false;

            for (var i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {
                var pi = this.raw[i],
                    pj = this.raw[j],
                    intersect = pi.y > y !== pj.y > y && x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x;

                if (intersect) {
                    inside = !inside;
                }
            }

            return options.type === "inside" ? inside : options.type === "outside" ? !inside : false;
        }
    }, {
        key: "parseSvgPath",
        value: function parseSvgPath(xml, force) {
            var _a, _b, _c;

            var forceDownload = force !== null && force !== void 0 ? force : false;

            if (this.paths !== undefined && !forceDownload) {
                return this.raw;
            }

            var container = this.container,
                options = this.options,
                parser = new DOMParser(),
                doc = parser.parseFromString(xml, "image/svg+xml"),
                svg = doc.getElementsByTagName("svg")[0];
            var svgPaths = svg.getElementsByTagName("path");

            if (!svgPaths.length) {
                svgPaths = doc.getElementsByTagName("path");
            }

            this.paths = [];

            for (var i = 0; i < svgPaths.length; i++) {
                var path = svgPaths.item(i);

                if (path) {
                    this.paths.push({
                        element: path,
                        length: path.getTotalLength()
                    });
                }
            }

            var pxRatio = container.retina.pixelRatio,
                scale = options.scale / pxRatio;
            this.dimension.width = parseFloat((_a = svg.getAttribute("width")) !== null && _a !== void 0 ? _a : "0") * scale;
            this.dimension.height = parseFloat((_b = svg.getAttribute("height")) !== null && _b !== void 0 ? _b : "0") * scale;
            var position = (_c = options.position) !== null && _c !== void 0 ? _c : {
                x: 50,
                y: 50
            };
            this.offset = {
                x: container.canvas.size.width * position.x / (100 * pxRatio) - this.dimension.width / 2,
                y: container.canvas.size.height * position.y / (100 * pxRatio) - this.dimension.height / 2
            };
            return parsePaths(this.paths, scale, this.offset);
        }
    }, {
        key: "downloadSvgPath",
        value: function() {
            var _downloadSvgPath = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee3(svgUrl, force) {
                var options, url, forceDownload, req;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                options = this.options, url = svgUrl || options.url, forceDownload = force !== null && force !== void 0 ? force : false;

                                if (!(!url || this.paths !== undefined && !forceDownload)) {
                                    _context3.next = 3;
                                    break;
                                }

                                return _context3.abrupt("return", this.raw);

                            case 3:
                                _context3.next = 5;
                                return fetch(url);

                            case 5:
                                req = _context3.sent;

                                if (req.ok) {
                                    _context3.next = 8;
                                    break;
                                }

                                throw new Error("tsParticles Error - Error occurred during polygon mask download");

                            case 8:
                                _context3.t0 = this;
                                _context3.next = 11;
                                return req.text();

                            case 11:
                                _context3.t1 = _context3.sent;
                                _context3.t2 = force;
                                return _context3.abrupt("return", _context3.t0.parseSvgPath.call(_context3.t0, _context3.t1, _context3.t2));

                            case 14:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function downloadSvgPath(_x2, _x3) {
                return _downloadSvgPath.apply(this, arguments);
            }

            return downloadSvgPath;
        }()
    }, {
        key: "drawPoints",
        value: function drawPoints() {
            if (!this.raw) {
                return;
            }

            var _iterator2 = _createForOfIteratorHelper(this.raw),
                _step2;

            try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var item = _step2.value;
                    this.container.particles.addParticle({
                        x: item.x,
                        y: item.y
                    });
                }
            } catch (err) {
                _iterator2.e(err);
            } finally {
                _iterator2.f();
            }
        }
    }, {
        key: "randomPoint",
        value: function randomPoint() {
            var container = this.container,
                options = this.options;
            var position;

            if (options.type === "inline") {
                switch (options.inline.arrangement) {
                    case "random-point":
                        position = this.getRandomPoint();
                        break;

                    case "random-length":
                        position = this.getRandomPointByLength();
                        break;

                    case "equidistant":
                        position = this.getEquidistantPointByIndex(container.particles.count);
                        break;

                    case "one-per-point":
                    case "per-point":
                    default:
                        position = this.getPointByIndex(container.particles.count);
                }
            } else {
                position = {
                    x: Math.random() * container.canvas.size.width,
                    y: Math.random() * container.canvas.size.height
                };
            }

            if (this.checkInsidePolygon(position)) {
                return position;
            } else {
                return this.randomPoint();
            }
        }
    }, {
        key: "getRandomPoint",
        value: function getRandomPoint() {
            if (!this.raw || !this.raw.length) {
                throw new Error(Constants.noPolygonDataLoaded);
            }

            var coords = itemFromArray(this.raw);
            return {
                x: coords.x,
                y: coords.y
            };
        }
    }, {
        key: "getRandomPointByLength",
        value: function getRandomPointByLength() {
            var _a, _b, _c;

            var options = this.options;

            if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new Error(Constants.noPolygonDataLoaded);
            }

            var path = itemFromArray(this.paths),
                distance = Math.floor(Math.random() * path.length) + 1,
                point = path.element.getPointAtLength(distance);
            return {
                x: point.x * options.scale + (((_b = this.offset) === null || _b === void 0 ? void 0 : _b.x) || 0),
                y: point.y * options.scale + (((_c = this.offset) === null || _c === void 0 ? void 0 : _c.y) || 0)
            };
        }
    }, {
        key: "getEquidistantPointByIndex",
        value: function getEquidistantPointByIndex(index) {
            var _a, _b, _c, _d, _e, _f, _g;

            var options = this.container.actualOptions,
                polygonMaskOptions = this.options;
            if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) throw new Error(Constants.noPolygonDataLoaded);
            var offset = 0,
                point;
            var totalLength = this.paths.reduce(function(tot, path) {
                    return tot + path.length;
                }, 0),
                distance = totalLength / options.particles.number.value;

            var _iterator3 = _createForOfIteratorHelper(this.paths),
                _step3;

            try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var path = _step3.value;
                    var pathDistance = distance * index - offset;

                    if (pathDistance <= path.length) {
                        point = path.element.getPointAtLength(pathDistance);
                        break;
                    } else {
                        offset += path.length;
                    }
                }
            } catch (err) {
                _iterator3.e(err);
            } finally {
                _iterator3.f();
            }

            return {
                x: ((_b = point === null || point === void 0 ? void 0 : point.x) !== null && _b !== void 0 ? _b : 0) * polygonMaskOptions.scale + ((_d = (_c = this.offset) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : 0),
                y: ((_e = point === null || point === void 0 ? void 0 : point.y) !== null && _e !== void 0 ? _e : 0) * polygonMaskOptions.scale + ((_g = (_f = this.offset) === null || _f === void 0 ? void 0 : _f.y) !== null && _g !== void 0 ? _g : 0)
            };
        }
    }, {
        key: "getPointByIndex",
        value: function getPointByIndex(index) {
            if (!this.raw || !this.raw.length) {
                throw new Error(Constants.noPolygonDataLoaded);
            }

            var coords = this.raw[index % this.raw.length];
            return {
                x: coords.x,
                y: coords.y
            };
        }
    }, {
        key: "createPath2D",
        value: function createPath2D() {
            var _this2 = this;

            var _a, _b;

            var options = this.options;

            if (!this.path2DSupported || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
                return;
            }

            var _iterator4 = _createForOfIteratorHelper(this.paths),
                _step4;

            try {
                var _loop = function _loop() {
                    var path = _step4.value;
                    var pathData = (_b = path.element) === null || _b === void 0 ? void 0 : _b.getAttribute("d");

                    if (pathData) {
                        var path2d = new Path2D(pathData),
                            matrix = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix(),
                            finalPath = new Path2D(),
                            transform = matrix.scale(options.scale);

                        if (finalPath.addPath) {
                            finalPath.addPath(path2d, transform);
                            path.path2d = finalPath;
                        } else {
                            delete path.path2d;
                        }
                    } else {
                        delete path.path2d;
                    }

                    if (path.path2d || !_this2.raw) {
                        return "continue";
                    }

                    path.path2d = new Path2D();
                    path.path2d.moveTo(_this2.raw[0].x, _this2.raw[0].y);

                    _this2.raw.forEach(function(pos, i) {
                        var _a;

                        if (i > 0) {
                            (_a = path.path2d) === null || _a === void 0 ? void 0 : _a.lineTo(pos.x, pos.y);
                        }
                    });

                    path.path2d.closePath();
                };

                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _ret = _loop();

                    if (_ret === "continue") continue;
                }
            } catch (err) {
                _iterator4.e(err);
            } finally {
                _iterator4.f();
            }
        }
    }, {
        key: "initRawData",
        value: function() {
            var _initRawData = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee4(force) {
                var options, data, svg, path, namespaces;
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                options = this.options;

                                if (!options.url) {
                                    _context4.next = 7;
                                    break;
                                }

                                _context4.next = 4;
                                return this.downloadSvgPath(options.url, force);

                            case 4:
                                this.raw = _context4.sent;
                                _context4.next = 8;
                                break;

                            case 7:
                                if (options.data) {
                                    data = options.data;

                                    if (typeof data !== "string") {
                                        path = data.path instanceof Array ? data.path.map(function(t) {
                                            return "<path d=\"".concat(t, "\" />");
                                        }).join("") : "<path d=\"".concat(data.path, "\" />");
                                        namespaces = 'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"';
                                        svg = "<svg ".concat(namespaces, " width=\"").concat(data.size.width, "\" height=\"").concat(data.size.height, "\">").concat(path, "</svg>");
                                    } else {
                                        svg = data;
                                    }

                                    this.raw = this.parseSvgPath(svg, force);
                                }

                            case 8:
                                this.createPath2D();

                            case 9:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function initRawData(_x4) {
                return _initRawData.apply(this, arguments);
            }

            return initRawData;
        }()
    }]);

    return PolygonMaskInstance;
}();