import _createForOfIteratorHelper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createForOfIteratorHelper";
import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import {
    Circle
} from "./Circle";
import {
    CircleWarp
} from "./CircleWarp";
import {
    Rectangle
} from "./Rectangle";
import {
    getDistance
} from "../../Utils/NumberUtils";
export var QuadTree = /*#__PURE__*/ function() {
    function QuadTree(rectangle, capacity) {
        _classCallCheck(this, QuadTree);

        this.rectangle = rectangle;
        this.capacity = capacity;
        this.points = [];
        this.divided = false;
    }

    _createClass(QuadTree, [{
        key: "insert",
        value: function insert(point) {
            var _a, _b, _c, _d, _e;

            if (!this.rectangle.contains(point.position)) {
                return false;
            }

            if (this.points.length < this.capacity) {
                this.points.push(point);
                return true;
            }

            if (!this.divided) {
                this.subdivide();
            }

            return (_e = ((_a = this.northEast) === null || _a === void 0 ? void 0 : _a.insert(point)) || ((_b = this.northWest) === null || _b === void 0 ? void 0 : _b.insert(point)) || ((_c = this.southEast) === null || _c === void 0 ? void 0 : _c.insert(point)) || ((_d = this.southWest) === null || _d === void 0 ? void 0 : _d.insert(point))) !== null && _e !== void 0 ? _e : false;
        }
    }, {
        key: "queryCircle",
        value: function queryCircle(position, radius) {
            return this.query(new Circle(position.x, position.y, radius));
        }
    }, {
        key: "queryCircleWarp",
        value: function queryCircleWarp(position, radius, containerOrSize) {
            var container = containerOrSize,
                size = containerOrSize;
            return this.query(new CircleWarp(position.x, position.y, radius, container.canvas !== undefined ? container.canvas.size : size));
        }
    }, {
        key: "queryRectangle",
        value: function queryRectangle(position, size) {
            return this.query(new Rectangle(position.x, position.y, size.width, size.height));
        }
    }, {
        key: "query",
        value: function query(range, found) {
            var _a, _b, _c, _d;

            var res = found !== null && found !== void 0 ? found : [];

            if (!range.intersects(this.rectangle)) {
                return [];
            }

            var _iterator = _createForOfIteratorHelper(this.points),
                _step;

            try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var p = _step.value;

                    if (!range.contains(p.position) && getDistance(range.position, p.position) > p.particle.getRadius()) {
                        continue;
                    }

                    res.push(p.particle);
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }

            if (this.divided) {
                (_a = this.northEast) === null || _a === void 0 ? void 0 : _a.query(range, res);
                (_b = this.northWest) === null || _b === void 0 ? void 0 : _b.query(range, res);
                (_c = this.southEast) === null || _c === void 0 ? void 0 : _c.query(range, res);
                (_d = this.southWest) === null || _d === void 0 ? void 0 : _d.query(range, res);
            }

            return res;
        }
    }, {
        key: "subdivide",
        value: function subdivide() {
            var x = this.rectangle.position.x,
                y = this.rectangle.position.y,
                w = this.rectangle.size.width,
                h = this.rectangle.size.height,
                capacity = this.capacity;
            this.northEast = new QuadTree(new Rectangle(x, y, w / 2, h / 2), capacity);
            this.northWest = new QuadTree(new Rectangle(x + w / 2, y, w / 2, h / 2), capacity);
            this.southEast = new QuadTree(new Rectangle(x, y + h / 2, w / 2, h / 2), capacity);
            this.southWest = new QuadTree(new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2), capacity);
            this.divided = true;
        }
    }]);

    return QuadTree;
}();