import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _get from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/get";
import _getPrototypeOf from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";
import _inherits from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _createSuper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createSuper";
import {
    Circle
} from "./Circle";
import {
    Rectangle
} from "./Rectangle";
export var CircleWarp = /*#__PURE__*/ function(_Circle) {
    _inherits(CircleWarp, _Circle);

    var _super = _createSuper(CircleWarp);

    function CircleWarp(x, y, radius, canvasSize) {
        var _this;

        _classCallCheck(this, CircleWarp);

        _this = _super.call(this, x, y, radius);
        _this.canvasSize = canvasSize;
        _this.canvasSize = Object.assign({}, canvasSize);
        return _this;
    }

    _createClass(CircleWarp, [{
        key: "contains",
        value: function contains(point) {
            if (_get(_getPrototypeOf(CircleWarp.prototype), "contains", this).call(this, point)) {
                return true;
            }

            var posNE = {
                x: point.x - this.canvasSize.width,
                y: point.y
            };

            if (_get(_getPrototypeOf(CircleWarp.prototype), "contains", this).call(this, posNE)) {
                return true;
            }

            var posSE = {
                x: point.x - this.canvasSize.width,
                y: point.y - this.canvasSize.height
            };

            if (_get(_getPrototypeOf(CircleWarp.prototype), "contains", this).call(this, posSE)) {
                return true;
            }

            var posSW = {
                x: point.x,
                y: point.y - this.canvasSize.height
            };
            return _get(_getPrototypeOf(CircleWarp.prototype), "contains", this).call(this, posSW);
        }
    }, {
        key: "intersects",
        value: function intersects(range) {
            if (_get(_getPrototypeOf(CircleWarp.prototype), "intersects", this).call(this, range)) {
                return true;
            }

            var rect = range,
                circle = range,
                newPos = {
                    x: range.position.x - this.canvasSize.width,
                    y: range.position.y - this.canvasSize.height
                };

            if (circle.radius !== undefined) {
                var biggerCircle = new Circle(newPos.x, newPos.y, circle.radius * 2);
                return _get(_getPrototypeOf(CircleWarp.prototype), "intersects", this).call(this, biggerCircle);
            } else if (rect.size !== undefined) {
                var rectSW = new Rectangle(newPos.x, newPos.y, rect.size.width * 2, rect.size.height * 2);
                return _get(_getPrototypeOf(CircleWarp.prototype), "intersects", this).call(this, rectSW);
            }

            return false;
        }
    }]);

    return CircleWarp;
}(Circle);