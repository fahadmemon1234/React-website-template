import _slicedToArray from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/slicedToArray";
import _createForOfIteratorHelper from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createForOfIteratorHelper";
import _asyncToGenerator from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "F:\\02-React\\05-Approve\\01-trydo\\trydo\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";

function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    };
    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function(innerFn, self, context) {
            var state = "suspendedStart";
            return function(method, arg) {
                if ("executing" === state) throw new Error("Generator is already running");
                if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                }
                for (context.method = method, context.arg = arg;;) {
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }
                    if ("next" === context.method) context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                        if ("suspendedStart" === state) throw state = "completed", context.arg;
                        context.dispatchException(context.arg);
                    } else "return" === context.method && context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);
                    if ("normal" === record.type) {
                        if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    }
                    "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                }
            };
        }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }

    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg,
                    value = result.value;
                return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
    }

    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
        this.tryEntries = [{
            tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                        for (; ++i < iterable.length;) {
                            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                        }
                        return next.value = undefined, next.done = !0, next;
                    };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }

    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(object) {
        var keys = [];
        for (var key in object) {
            keys.push(key);
        }
        return keys.reverse(),
            function next() {
                for (; keys.length;) {
                    var key = keys.pop();
                    if (key in object) return next.value = key, next.done = !1, next;
                }
                return next.done = !0, next;
            };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                for (var name in this) {
                    "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
                }
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;

            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i],
                    record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                        hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        catch: function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}

import {
    clear as _clear,
    drawConnectLine as _drawConnectLine,
    drawGrabLine as _drawGrabLine,
    drawParticle as _drawParticle,
    drawParticlePlugin as _drawParticlePlugin,
    drawPlugin as _drawPlugin,
    gradient,
    paintBase as _paintBase
} from "../Utils/CanvasUtils";
import {
    colorToHsl,
    colorToRgb,
    getStyleFromHsl,
    getStyleFromRgb
} from "../Utils/ColorUtils";
import {
    Constants
} from "./Utils/Constants";
import {
    deepExtend
} from "../Utils/Utils";
export var Canvas = /*#__PURE__*/ function() {
    function Canvas(container) {
        _classCallCheck(this, Canvas);

        this.container = container;
        this.size = {
            height: 0,
            width: 0
        };
        this.context = null;
        this.generatedCanvas = false;
    }

    _createClass(Canvas, [{
        key: "init",
        value: function init() {
            this.resize();
            this.initStyle();
            this.initCover();
            this.initTrail();
            this.initBackground();
            this.paint();
        }
    }, {
        key: "loadCanvas",
        value: function loadCanvas(canvas) {
            var _a;

            if (this.generatedCanvas) {
                (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
            }

            this.generatedCanvas = canvas.dataset && Constants.generatedAttribute in canvas.dataset ? canvas.dataset[Constants.generatedAttribute] === "true" : this.generatedCanvas;
            this.element = canvas;
            this.originalStyle = deepExtend({}, this.element.style);
            this.size.height = canvas.offsetHeight;
            this.size.width = canvas.offsetWidth;
            this.context = this.element.getContext("2d");
            this.container.retina.init();
            this.initBackground();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var _this = this;

            var _a;

            if (this.generatedCanvas) {
                (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
            }

            this.draw(function(ctx) {
                _clear(ctx, _this.size);
            });
        }
    }, {
        key: "paint",
        value: function paint() {
            var _this2 = this;

            var options = this.container.actualOptions;
            this.draw(function(ctx) {
                if (options.backgroundMask.enable && options.backgroundMask.cover) {
                    _clear(ctx, _this2.size);

                    _this2.paintBase(_this2.coverColorStyle);
                } else {
                    _this2.paintBase();
                }
            });
        }
    }, {
        key: "clear",
        value: function clear() {
            var _this3 = this;

            var options = this.container.actualOptions,
                trail = options.particles.move.trail;

            if (options.backgroundMask.enable) {
                this.paint();
            } else if (trail.enable && trail.length > 0 && this.trailFillColor) {
                this.paintBase(getStyleFromRgb(this.trailFillColor, 1 / trail.length));
            } else {
                this.draw(function(ctx) {
                    _clear(ctx, _this3.size);
                });
            }
        }
    }, {
        key: "windowResize",
        value: function() {
            var _windowResize = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {
                var container, needsRefresh, _iterator, _step, _step$value, plugin;

                return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (this.element) {
                                    _context.next = 2;
                                    break;
                                }

                                return _context.abrupt("return");

                            case 2:
                                this.resize();
                                container = this.container, needsRefresh = container.updateActualOptions();
                                container.particles.setDensity();
                                _iterator = _createForOfIteratorHelper(container.plugins);

                                try {
                                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                        _step$value = _slicedToArray(_step.value, 2), plugin = _step$value[1];

                                        if (plugin.resize !== undefined) {
                                            plugin.resize();
                                        }
                                    }
                                } catch (err) {
                                    _iterator.e(err);
                                } finally {
                                    _iterator.f();
                                }

                                if (!needsRefresh) {
                                    _context.next = 10;
                                    break;
                                }

                                _context.next = 10;
                                return container.refresh();

                            case 10:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function windowResize() {
                return _windowResize.apply(this, arguments);
            }

            return windowResize;
        }()
    }, {
        key: "resize",
        value: function resize() {
            if (!this.element) {
                return;
            }

            var container = this.container,
                pxRatio = container.retina.pixelRatio,
                size = container.canvas.size,
                newSize = {
                    width: this.element.offsetWidth * pxRatio,
                    height: this.element.offsetHeight * pxRatio
                };

            if (newSize.height === size.height && newSize.width === size.width && newSize.height === this.element.height && newSize.width === this.element.width) {
                return;
            }

            var oldSize = Object.assign({}, size);
            this.element.width = size.width = this.element.offsetWidth * pxRatio;
            this.element.height = size.height = this.element.offsetHeight * pxRatio;

            if (this.container.started) {
                this.resizeFactor = {
                    width: size.width / oldSize.width,
                    height: size.height / oldSize.height
                };
            }
        }
    }, {
        key: "drawConnectLine",
        value: function drawConnectLine(p1, p2) {
            var _this4 = this;

            this.draw(function(ctx) {
                var _a;

                var lineStyle = _this4.lineStyle(p1, p2);

                if (!lineStyle) {
                    return;
                }

                var pos1 = p1.getPosition(),
                    pos2 = p2.getPosition();

                _drawConnectLine(ctx, (_a = p1.retina.linksWidth) !== null && _a !== void 0 ? _a : _this4.container.retina.linksWidth, lineStyle, pos1, pos2);
            });
        }
    }, {
        key: "drawGrabLine",
        value: function drawGrabLine(particle, lineColor, opacity, mousePos) {
            var container = this.container;
            this.draw(function(ctx) {
                var _a;

                var beginPos = particle.getPosition();

                _drawGrabLine(ctx, (_a = particle.retina.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth, beginPos, mousePos, lineColor, opacity);
            });
        }
    }, {
        key: "drawParticle",
        value: function drawParticle(particle, delta) {
            var _this5 = this;

            var _a, _b, _c, _d, _e, _f;

            if (particle.spawning || particle.destroyed) {
                return;
            }

            var radius = particle.getRadius();

            if (radius <= 0) {
                return;
            }

            var pfColor = particle.getFillColor(),
                psColor = (_a = particle.getStrokeColor()) !== null && _a !== void 0 ? _a : pfColor;

            if (!pfColor && !psColor) {
                return;
            }

            var _this$getPluginPartic = this.getPluginParticleColors(particle),
                _this$getPluginPartic2 = _slicedToArray(_this$getPluginPartic, 2),
                fColor = _this$getPluginPartic2[0],
                sColor = _this$getPluginPartic2[1];

            if (!fColor || !sColor) {
                if (!fColor) {
                    fColor = pfColor ? pfColor : undefined;
                }

                if (!sColor) {
                    sColor = psColor ? psColor : undefined;
                }
            }

            var options = this.container.actualOptions,
                zIndexOptions = particle.options.zIndex,
                zOpacityFactor = Math.pow(1 - particle.zIndexFactor, zIndexOptions.opacityRate),
                opacity = (_d = (_b = particle.bubble.opacity) !== null && _b !== void 0 ? _b : (_c = particle.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1,
                strokeOpacity = (_f = (_e = particle.stroke) === null || _e === void 0 ? void 0 : _e.opacity) !== null && _f !== void 0 ? _f : opacity,
                zOpacity = opacity * zOpacityFactor,
                zStrokeOpacity = strokeOpacity * zOpacityFactor;
            var colorStyles = {
                fill: fColor ? getStyleFromHsl(fColor, zOpacity) : undefined
            };
            colorStyles.stroke = sColor ? getStyleFromHsl(sColor, zStrokeOpacity) : colorStyles.fill;
            this.draw(function(ctx) {
                var zSizeFactor = Math.pow(1 - particle.zIndexFactor, zIndexOptions.sizeRate),
                    container = _this5.container;

                var _iterator2 = _createForOfIteratorHelper(container.particles.updaters),
                    _step2;

                try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var updater = _step2.value;

                        if (updater.beforeDraw) {
                            updater.beforeDraw(particle);
                        }

                        if (updater.getColorStyles) {
                            var _updater$getColorStyl = updater.getColorStyles(particle, ctx, radius, zOpacity),
                                fill = _updater$getColorStyl.fill,
                                stroke = _updater$getColorStyl.stroke;

                            if (fill) {
                                colorStyles.fill = fill;
                            }

                            if (stroke) {
                                colorStyles.stroke = stroke;
                            }
                        }
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally {
                    _iterator2.f();
                }

                _drawParticle(container, ctx, particle, delta, colorStyles, options.backgroundMask.enable, options.backgroundMask.composite, radius * zSizeFactor, zOpacity, particle.options.shadow);

                var _iterator3 = _createForOfIteratorHelper(container.particles.updaters),
                    _step3;

                try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        var _updater = _step3.value;

                        if (_updater.afterDraw) {
                            _updater.afterDraw(particle);
                        }
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally {
                    _iterator3.f();
                }
            });
        }
    }, {
        key: "drawPlugin",
        value: function drawPlugin(plugin, delta) {
            this.draw(function(ctx) {
                _drawPlugin(ctx, plugin, delta);
            });
        }
    }, {
        key: "drawParticlePlugin",
        value: function drawParticlePlugin(plugin, particle, delta) {
            this.draw(function(ctx) {
                _drawParticlePlugin(ctx, plugin, particle, delta);
            });
        }
    }, {
        key: "initBackground",
        value: function initBackground() {
            var options = this.container.actualOptions,
                background = options.background,
                element = this.element,
                elementStyle = element === null || element === void 0 ? void 0 : element.style;

            if (!elementStyle) {
                return;
            }

            if (background.color) {
                var color = colorToRgb(background.color);
                elementStyle.backgroundColor = color ? getStyleFromRgb(color, background.opacity) : "";
            } else {
                elementStyle.backgroundColor = "";
            }

            elementStyle.backgroundImage = background.image || "";
            elementStyle.backgroundPosition = background.position || "";
            elementStyle.backgroundRepeat = background.repeat || "";
            elementStyle.backgroundSize = background.size || "";
        }
    }, {
        key: "draw",
        value: function draw(cb) {
            if (!this.context) {
                return;
            }

            return cb(this.context);
        }
    }, {
        key: "initCover",
        value: function initCover() {
            var options = this.container.actualOptions,
                cover = options.backgroundMask.cover,
                color = cover.color,
                coverRgb = colorToRgb(color);

            if (coverRgb) {
                var coverColor = {
                    r: coverRgb.r,
                    g: coverRgb.g,
                    b: coverRgb.b,
                    a: cover.opacity
                };
                this.coverColorStyle = getStyleFromRgb(coverColor, coverColor.a);
            }
        }
    }, {
        key: "initTrail",
        value: function initTrail() {
            var options = this.container.actualOptions,
                trail = options.particles.move.trail,
                fillColor = colorToRgb(trail.fillColor);

            if (fillColor) {
                var _trail = options.particles.move.trail;
                this.trailFillColor = {
                    r: fillColor.r,
                    g: fillColor.g,
                    b: fillColor.b,
                    a: 1 / _trail.length
                };
            }
        }
    }, {
        key: "getPluginParticleColors",
        value: function getPluginParticleColors(particle) {
            var fColor, sColor;

            var _iterator4 = _createForOfIteratorHelper(this.container.plugins),
                _step4;

            try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _step4$value = _slicedToArray(_step4.value, 2),
                        plugin = _step4$value[1];

                    if (!fColor && plugin.particleFillColor) {
                        fColor = colorToHsl(plugin.particleFillColor(particle));
                    }

                    if (!sColor && plugin.particleStrokeColor) {
                        sColor = colorToHsl(plugin.particleStrokeColor(particle));
                    }

                    if (fColor && sColor) {
                        break;
                    }
                }
            } catch (err) {
                _iterator4.e(err);
            } finally {
                _iterator4.f();
            }

            return [fColor, sColor];
        }
    }, {
        key: "initStyle",
        value: function initStyle() {
            var element = this.element,
                options = this.container.actualOptions;

            if (!element) {
                return;
            }

            var originalStyle = this.originalStyle;

            if (options.fullScreen.enable) {
                this.originalStyle = deepExtend({}, element.style);
                element.style.setProperty("position", "fixed", "important");
                element.style.setProperty("z-index", options.fullScreen.zIndex.toString(10), "important");
                element.style.setProperty("top", "0", "important");
                element.style.setProperty("left", "0", "important");
                element.style.setProperty("width", "100%", "important");
                element.style.setProperty("height", "100%", "important");
            } else if (originalStyle) {
                element.style.position = originalStyle.position;
                element.style.zIndex = originalStyle.zIndex;
                element.style.top = originalStyle.top;
                element.style.left = originalStyle.left;
                element.style.width = originalStyle.width;
                element.style.height = originalStyle.height;
            }

            for (var key in options.style) {
                if (!key || !options.style) {
                    continue;
                }

                var value = options.style[key];

                if (!value) {
                    continue;
                }

                element.style.setProperty(key, value, "important");
            }
        }
    }, {
        key: "paintBase",
        value: function paintBase(baseColor) {
            var _this6 = this;

            this.draw(function(ctx) {
                _paintBase(ctx, _this6.size, baseColor);
            });
        }
    }, {
        key: "lineStyle",
        value: function lineStyle(p1, p2) {
            var _this7 = this;

            return this.draw(function(ctx) {
                var options = _this7.container.actualOptions,
                    connectOptions = options.interactivity.modes.connect;
                return gradient(ctx, p1, p2, connectOptions.links.opacity);
            });
        }
    }]);

    return Canvas;
}();